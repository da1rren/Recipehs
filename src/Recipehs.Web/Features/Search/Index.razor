@using Nest
@using Recipehs.Shared
@using Recipehs.Shared.Models
@inject ElasticClient _elasticClient
@page "/"

<PageTitle>Index</PageTitle>

<h1>Hello, world!</h1>

Welcome to your new app.

<EditForm Model="@_viewModel" OnValidSubmit="@HandleValidSubmit">
    <DataAnnotationsValidator/>
    <ValidationSummary/>

    <InputText id="name" @bind-Value="_viewModel.Query"/>

    <button type="submit">Submit</button>
</EditForm>

@if (_viewModel.HasSearched && !_recipes.Any())
{
    <h2 class="text-danger">No results</h2>
}

@foreach (var recipe in _recipes)
{
    <h2>@recipe.Title</h2>

    <h3>Steps</h3>
    <ul>
        @foreach (var ingredient in recipe.Ingredient)
        {
            <li>@ingredient</li>
        }
    </ul>

    <h3>Steps</h3>
    <ul>
        @foreach (var step in recipe.Steps)
        {
            <li>@step</li>
        }
    </ul>
}



@code {
    private readonly SearchViewModel _viewModel = new();

    private IEnumerable<Recipe> _recipes = Enumerable.Empty<Recipe>();

    private async Task HandleValidSubmit()
    {
        _viewModel.HasSearched = true;

        if (string.IsNullOrEmpty(_viewModel.Query))
        {
            _recipes = Enumerable.Empty<Recipe>();
            return;
        }

        var searchResponse = await _elasticClient.SearchAsync<Recipe>(s => s
            .Index(WellKnown.ElasticSearch.RECIPE_WILDCARD_INDEX)
            .Query(q => q
                .MultiMatch(mm => mm
                    .Fields(f => f.
                        Field(ff => ff.Title, boost: 2).
                        Field(ff => ff.Ingredient))
                    .Query(_viewModel.Query))
            ));

        _recipes = searchResponse.Documents;
    }

}